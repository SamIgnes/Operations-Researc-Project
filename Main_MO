import matplotlib.pyplot as plt
import matplotlib.patches as patches
import heapq
import math
import random

class Node:
    def __init__(self, point, parent=None):
        self.point = point
        self.parent = parent
        self.g = 0  # Distance from start node
        self.h = 0  # Heuristic distance to end node
        self.penalty = 0  # Penalty for being near barriers
        self.f = 0  # Total cost

    def __lt__(self, other):
        return self.f < other.f

def heuristic(a, b):
    return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)

def calculate_penalty(point, barriers):
    min_distance = float('inf')
    for barrier in barriers:
        for vertex in barrier:
            distance = heuristic(point, vertex)
            if distance < min_distance:
                min_distance = distance
    return 10 / (min_distance + 1)  # Penalizzazione inversa

def astar(start, end, barriers):
    open_list = []
    closed_list = set()
    start_node = Node(start)
    end_node = Node(end)
    
    start_node.h = heuristic(start, end)
    start_node.penalty = calculate_penalty(start, barriers)
    start_node.f = start_node.g + start_node.h + start_node.penalty
    heapq.heappush(open_list, start_node)

    while open_list:
        current_node = heapq.heappop(open_list)
        closed_list.add(current_node.point)

        if current_node.point == end_node.point:
            path = []
            while current_node:
                path.append(current_node.point)
                current_node = current_node.parent
            return path[::-1]

        neighbors = get_neighbors(current_node.point, barriers)
        for next_point in neighbors:
            if next_point in closed_list:
                continue

            neighbor_node = Node(next_point, current_node)
            neighbor_node.g = current_node.g + heuristic(current_node.point, neighbor_node.point)
            neighbor_node.h = heuristic(neighbor_node.point, end_node.point)
            neighbor_node.penalty = calculate_penalty(next_point, barriers)
            neighbor_node.f = neighbor_node.g + neighbor_node.h + neighbor_node.penalty

            if add_to_open(open_list, neighbor_node): 
                heapq.heappush(open_list, neighbor_node)

    return None

def get_neighbors(point, barriers):
    neighbors = []
    step_size = 0.5  # Step size for moving to neighbors

    for dx in [-step_size, 0, step_size]: # Aumentare questi for 
        for dy in [-step_size, 0, step_size]: #Aumentare questi for 
            if dx == 0 and dy == 0:
                continue
            neighbor = (point[0] + dx, point[1] + dy)
            if not is_collision(neighbor, barriers):
                neighbors.append(neighbor)

    return neighbors

def is_collision(point, barriers):
    for barrier in barriers:
        polygon = patches.Polygon(barrier, closed=True)
        if polygon.contains_point(point):
            return True
    return False

def add_to_open(open_list, neighbor_node):
    for node in open_list:
        if neighbor_node.point == node.point and neighbor_node.f >= node.f: 
            return False
    return True

def plot_environment_and_path(barriers, paths):
    fig, ax = plt.subplots()
    ax.set_xlim(0, 100)
    ax.set_ylim(0, 100)

    for barrier in barriers:
        polygon = patches.Polygon(barrier, closed=True, edgecolor='r', facecolor='none')
        ax.add_patch(polygon)

    colors = ['b', 'g', 'm', 'c', 'y']  # Esempio di colori diversi per i percorsi

    for idx, path in enumerate(paths):
        if path:
            x_coords = [point[0] for point in path]
            y_coords = [point[1] for point in path]
            ax.plot(x_coords, y_coords, linestyle='-', color=colors[idx % len(colors)])

    ax.set_xlabel('X Coordinate')
    ax.set_ylabel('Y Coordinate')
    ax.set_title('Path Finding')
    plt.grid(True)
    plt.gca().set_aspect('equal', adjustable='box')


class Particle:
    def __init__(self, position, velocity):
        self.position = position
        self.velocity = velocity
        self.best_position = position
        self.best_cost = float('inf')

def smoothness(position):
    smooth = 0
    for i in range(1,len(position)-2):

        if (position[i+1][0]-position[i][0] == 0) & (position[i][0]-position[i-1][0] == 0) :
            smooth = 3
        elif position[i+1][0]-position[i][0] == 0 :
            smooth = abs(math.pi/2-math.atan((position[i][1]-position[i-1][1])/(position[i][0]-position[i-1][0])))
        elif position[i][0]-position[i-1][0] == 0 :
            smooth = abs(math.pi/2-math.atan((position[i+1][1]-position[i][1])/(position[i+1][0]-position[i][0])))
        else:
            smooth += abs(math.atan((position[i+1][1]-position[i][1])/(position[i+1][0]-position[i][0]))-math.atan((position[i][1]-position[i-1][1])/(position[i][0]-position[i-1][0])))
    
            
    return smooth/68

def evaluate_cost(position, end, barriers):
    total_cost = 0
    for i in range(len(position) - 1):
        total_cost += heuristic(position[i], position[i+1])
    
    total_cost += heuristic(position[-1], end)
    total_cost += calculate_penalty(position[-1], barriers)
    #total_cost += smoothness(position)

    return total_cost

def pso_optimization(start, end, barriers, best_path_astar):
    num_particles = 100
    max_iterations = 2000
    inertia_weight = 0.7
    cognitive_param = 1.5
    social_param = 1.5

    particles = []
    for _ in range(num_particles):
        # Initialize particles around the best path found by A*
        initial_position = [best_path_astar[0]] + \
                   [(point[0] + random.uniform(-0.25, 0.25), point[1] + random.uniform(-0.25, 0.25)) 
                    for point in best_path_astar[1:-1]] + \
                   [best_path_astar[-1]]
        initial_velocity = [(0, 0) for _ in initial_position]
        particles.append(Particle(initial_position, initial_velocity))

    global_best_position = best_path_astar

    global_best_cost = evaluate_cost(global_best_position, end, barriers)

    for _ in range(max_iterations):
        for particle in particles:
            # Update particle velocity
            for i in range(len(particle.position)):
                r1, r2 = random.uniform(0, 1), random.uniform(0, 1)
                cognitive_velocity = (cognitive_param * r1 * 
                                      (particle.best_position[i][0] - particle.position[i][0]), 
                                      cognitive_param * r1 * 
                                      (particle.best_position[i][1] - particle.position[i][1]))
                social_velocity = (social_param * r2 * 
                                   (global_best_position[i][0] - particle.position[i][0]), 
                                   social_param * r2 * 
                                   (global_best_position[i][1] - particle.position[i][1]))
                particle.velocity[i] = (inertia_weight * particle.velocity[i][0] + cognitive_velocity[0] + social_velocity[0],
                                        inertia_weight * particle.velocity[i][1] + cognitive_velocity[1] + social_velocity[1])
            
            # Update particle position
            new_position = [(particle.position[i][0] + particle.velocity[i][0], 
                             particle.position[i][1] + particle.velocity[i][1]) 
                            for i in range(len(particle.position))]
            
            # Evaluate new position
            new_cost = evaluate_cost(new_position, end, barriers)

            # Update particle's best position if improved
            if new_cost < particle.best_cost:
                particle.best_position = new_position
                particle.best_cost = new_cost
            
            # Update global best if improved
            if new_cost < global_best_cost:
                global_best_position = new_position
                global_best_cost = new_cost

    return global_best_position


# Define the barriers as lists of (x, y) coordinates (irregular polygons)
barriers = [
    [(10, 10), (20, 10), (15, 20)],  # Triangle barrier
    [(30, 30), (50, 30), (50, 50), (30, 50)],  # Rectangle barrier
    [(70, 70), (80, 65), (85, 75), (75, 80)],  # Irregular quadrilateral barrier
]

# Define start and end points
start = (0, 0)
end = (90, 90)

# Dopo aver trovato il percorso migliore con A*
best_path_astar = astar(start, end, barriers)

# Ottimizza il percorso trovato con PSO
optimized_path = pso_optimization(start, end, barriers, best_path_astar)


plot_environment_and_path(barriers, [best_path_astar])

# Plot percorso ottimizzato con PSO
plot_environment_and_path(barriers, [optimized_path])

plt.show()